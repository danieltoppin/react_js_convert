{"ast":null,"code":"// export const Title = ({ title, category, isSelected }) => {\n//   const inverted = useInvertedScale();\n//   const x = isSelected ? 30 : 15;\n//   const y = x;\n\n//   return (\n//     <motion.div\n//       className=\"title-container\"\n//       initial={false}\n//       animate={{ x, y }}\n//       transition={isSelected ? openSpring : closeSpring}\n//       transformTemplate={scaleTranslate}\n//       style={{ ...inverted, originX: 0, originY: 0 }}\n//     >\n//       <span className=\"category\">{category}</span>\n//       <h2>{title}</h2>\n//     </motion.div>\n//   );\n// };\n\n/**\n * `transform` is order-dependent, so if you scale(0.5) before translateX(100px),\n * the visual translate will only be 50px.\n *\n * The intuitive pattern is to translate before doing things like scale and\n * rotate that will affect the coordinate space. So Framer Motion takes an\n * opinion on that and allows you to animate them\n * individually without having to write a whole transform string.\n *\n * However in this component we're doing something novel by inverting\n * the scale of the parent component. Because of this we want to translate\n * through scaled coordinate space, and can use the transformTemplate prop to do so.\n */\nvar scaleTranslate = function scaleTranslate(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    scaleX = _ref.scaleX,\n    scaleY = _ref.scaleY;\n  return \"scaleX(\".concat(scaleX, \") scaleY(\").concat(scaleY, \") translate(\").concat(x, \", \").concat(y, \") translateZ(0)\");\n};\nexport {};","map":{"version":3,"names":["scaleTranslate","x","y","scaleX","scaleY"],"sources":["/Users/gbdantop/Downloads/app-store-ui-using-react-and-framer-motion/src/Card/Title.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { motion, useInvertedScale } from \"framer-motion\";\nimport { closeSpring, openSpring } from \"./animations\";\n\n// export const Title = ({ title, category, isSelected }) => {\n//   const inverted = useInvertedScale();\n//   const x = isSelected ? 30 : 15;\n//   const y = x;\n\n//   return (\n//     <motion.div\n//       className=\"title-container\"\n//       initial={false}\n//       animate={{ x, y }}\n//       transition={isSelected ? openSpring : closeSpring}\n//       transformTemplate={scaleTranslate}\n//       style={{ ...inverted, originX: 0, originY: 0 }}\n//     >\n//       <span className=\"category\">{category}</span>\n//       <h2>{title}</h2>\n//     </motion.div>\n//   );\n// };\n\n/**\n * `transform` is order-dependent, so if you scale(0.5) before translateX(100px),\n * the visual translate will only be 50px.\n *\n * The intuitive pattern is to translate before doing things like scale and\n * rotate that will affect the coordinate space. So Framer Motion takes an\n * opinion on that and allows you to animate them\n * individually without having to write a whole transform string.\n *\n * However in this component we're doing something novel by inverting\n * the scale of the parent component. Because of this we want to translate\n * through scaled coordinate space, and can use the transformTemplate prop to do so.\n */\nconst scaleTranslate = ({ x, y, scaleX, scaleY }) =>\n  `scaleX(${scaleX}) scaleY(${scaleY}) translate(${x}, ${y}) translateZ(0)`;\n"],"mappings":"AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMA,cAAc,GAAG,SAAjBA,cAAc;EAAA,IAAMC,CAAC,QAADA,CAAC;IAAEC,CAAC,QAADA,CAAC;IAAEC,MAAM,QAANA,MAAM;IAAEC,MAAM,QAANA,MAAM;EAAA,wBAClCD,MAAM,sBAAYC,MAAM,yBAAeH,CAAC,eAAKC,CAAC;AAAA,CAAiB;AAAC"},"metadata":{},"sourceType":"module"}